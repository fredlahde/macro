// Code generated by github.com/worldiety/macro. DO NOT EDIT.

package domain

import (
	json "encoding/json"
	xcompo "example/domain/xcompo"
	fmt "fmt"
)

// A Component is a sum type or tagged union.
// Actually, we can generate different flavors, so that Go makes fun for modelling business stuff.
type Component struct {
	ordinal int
	value   any
}

func (e Component) Unwrap() any {
	return e.value
}

func (e Component) Ordinal() int {
	return e.ordinal
}

func (e Component) Valid() bool {
	return e.ordinal > 0
}

// Switch provides an exhaustive and type safe closure callback mechanic. Nil callbacks are allowed. Unmatched branches are delegated into a default case.
func (e Component) Switch(onButton func(Button), onTextField func(TextField), onText func(Text), onChapter func(Chapter), onRichText func(xcompo.RichText), onIcon func(xcompo.Icon), onstring func(string), onstringSlice func([]string), onTextSlice func([]Text), _onDefault func(any)) {
	switch e.ordinal {
	case 1:
		if onButton != nil {
			onButton(e.value.(Button))
			return
		}
	case 2:
		if onTextField != nil {
			onTextField(e.value.(TextField))
			return
		}
	case 3:
		if onText != nil {
			onText(e.value.(Text))
			return
		}
	case 4:
		if onChapter != nil {
			onChapter(e.value.(Chapter))
			return
		}
	case 5:
		if onRichText != nil {
			onRichText(e.value.(xcompo.RichText))
			return
		}
	case 6:
		if onIcon != nil {
			onIcon(e.value.(xcompo.Icon))
			return
		}
	case 7:
		if onstring != nil {
			onstring(e.value.(string))
			return
		}
	case 8:
		if onstringSlice != nil {
			onstringSlice(e.value.([]string))
			return
		}
	case 9:
		if onTextSlice != nil {
			onTextSlice(e.value.([]Text))
			return
		}
	}

	if _onDefault != nil {
		_onDefault(e.value)
	}
}

func (e Component) AsButton() (Button, bool) {
	var zero Button
	if e.ordinal == 1 {
		return e.value.(Button), true
	}

	return zero, false
}

func (e Component) WithButton(v Button) Component {
	e.ordinal = 1
	e.value = v
	return e
}

func (e Component) AsTextField() (TextField, bool) {
	var zero TextField
	if e.ordinal == 2 {
		return e.value.(TextField), true
	}

	return zero, false
}

func (e Component) WithTextField(v TextField) Component {
	e.ordinal = 2
	e.value = v
	return e
}

func (e Component) AsText() (Text, bool) {
	var zero Text
	if e.ordinal == 3 {
		return e.value.(Text), true
	}

	return zero, false
}

func (e Component) WithText(v Text) Component {
	e.ordinal = 3
	e.value = v
	return e
}

func (e Component) AsChapter() (Chapter, bool) {
	var zero Chapter
	if e.ordinal == 4 {
		return e.value.(Chapter), true
	}

	return zero, false
}

func (e Component) WithChapter(v Chapter) Component {
	e.ordinal = 4
	e.value = v
	return e
}

func (e Component) AsRichText() (xcompo.RichText, bool) {
	var zero xcompo.RichText
	if e.ordinal == 5 {
		return e.value.(xcompo.RichText), true
	}

	return zero, false
}

func (e Component) WithRichText(v xcompo.RichText) Component {
	e.ordinal = 5
	e.value = v
	return e
}

func (e Component) AsIcon() (xcompo.Icon, bool) {
	var zero xcompo.Icon
	if e.ordinal == 6 {
		return e.value.(xcompo.Icon), true
	}

	return zero, false
}

func (e Component) WithIcon(v xcompo.Icon) Component {
	e.ordinal = 6
	e.value = v
	return e
}

func (e Component) Asstring() (string, bool) {
	var zero string
	if e.ordinal == 7 {
		return e.value.(string), true
	}

	return zero, false
}

func (e Component) Withstring(v string) Component {
	e.ordinal = 7
	e.value = v
	return e
}

func (e Component) AsstringSlice() ([]string, bool) {
	var zero []string
	if e.ordinal == 8 {
		return e.value.([]string), true
	}

	return zero, false
}

func (e Component) WithstringSlice(v []string) Component {
	e.ordinal = 8
	e.value = v
	return e
}

func (e Component) AsTextSlice() ([]Text, bool) {
	var zero []Text
	if e.ordinal == 9 {
		return e.value.([]Text), true
	}

	return zero, false
}

func (e Component) WithTextSlice(v []Text) Component {
	e.ordinal = 9
	e.value = v
	return e
}

func (e Component) MarshalJSON() ([]byte, error) {
	if e.ordinal == 0 {
		return nil, fmt.Errorf("marshalling a zero value is not allowed")
	}

	return json.Marshal(e)
}

func (e *Component) UnmarshalJSON(bytes []byte) error {
	typeOnly := struct {
		Type string `json:"type"`
	}{}
	if err := json.Unmarshal(bytes, &typeOnly); err != nil {
		return err
	}
	switch typeOnly.Type {
	case "Button":
		var value Button
		if err := json.Unmarshal(bytes, &value); err != nil {
			return fmt.Errorf("cannot unmarshal variant 'Button'")
		}
		e.ordinal = 1
	case "TextField":
		var value TextField
		if err := json.Unmarshal(bytes, &value); err != nil {
			return fmt.Errorf("cannot unmarshal variant 'TextField'")
		}
		e.ordinal = 2
	case "Text":
		var value Text
		if err := json.Unmarshal(bytes, &value); err != nil {
			return fmt.Errorf("cannot unmarshal variant 'Text'")
		}
		e.ordinal = 3
	case "Chapter":
		var value Chapter
		if err := json.Unmarshal(bytes, &value); err != nil {
			return fmt.Errorf("cannot unmarshal variant 'Chapter'")
		}
		e.ordinal = 4
	case "RichText":
		var value xcompo.RichText
		if err := json.Unmarshal(bytes, &value); err != nil {
			return fmt.Errorf("cannot unmarshal variant 'xcompo.RichText'")
		}
		e.ordinal = 5
	case "Icon":
		var value xcompo.Icon
		if err := json.Unmarshal(bytes, &value); err != nil {
			return fmt.Errorf("cannot unmarshal variant 'xcompo.Icon'")
		}
		e.ordinal = 6
	case "string":
		var value string
		if err := json.Unmarshal(bytes, &value); err != nil {
			return fmt.Errorf("cannot unmarshal variant 'string'")
		}
		e.ordinal = 7
	case "stringSlice":
		var value []string
		if err := json.Unmarshal(bytes, &value); err != nil {
			return fmt.Errorf("cannot unmarshal variant '[]string'")
		}
		e.ordinal = 8
	case "TextSlice":
		var value []Text
		if err := json.Unmarshal(bytes, &value); err != nil {
			return fmt.Errorf("cannot unmarshal variant '[]Text'")
		}
		e.ordinal = 9
	default:
		return fmt.Errorf("unknown type variant name '%s'", typeOnly.Type)
	}

	return nil
}

func MatchComponent[R any](e Component, onButton func(Button) R, onTextField func(TextField) R, onText func(Text) R, onChapter func(Chapter) R, onRichText func(xcompo.RichText) R, onIcon func(xcompo.Icon) R, onstring func(string) R, onstringSlice func([]string) R, onTextSlice func([]Text) R, _onDefault func(any) R) R {
	if _onDefault == nil {
		panic(`missing default match: cannot guarantee exhaustive matching`)
	}

	switch e.ordinal {
	case 1:
		if onButton != nil {
			return onButton(e.value.(Button))
		}
	case 2:
		if onTextField != nil {
			return onTextField(e.value.(TextField))
		}
	case 3:
		if onText != nil {
			return onText(e.value.(Text))
		}
	case 4:
		if onChapter != nil {
			return onChapter(e.value.(Chapter))
		}
	case 5:
		if onRichText != nil {
			return onRichText(e.value.(xcompo.RichText))
		}
	case 6:
		if onIcon != nil {
			return onIcon(e.value.(xcompo.Icon))
		}
	case 7:
		if onstring != nil {
			return onstring(e.value.(string))
		}
	case 8:
		if onstringSlice != nil {
			return onstringSlice(e.value.([]string))
		}
	case 9:
		if onTextSlice != nil {
			return onTextSlice(e.value.([]Text))
		}
	}

	return _onDefault(e.value)
}
