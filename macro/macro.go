package macro

import (
	"bytes"
	"fmt"
	"github.com/worldiety/macro/ast/golang"
	"github.com/worldiety/macro/ast/wdy"
	"github.com/worldiety/macro/pkg/src/ast"
	golang2 "github.com/worldiety/macro/pkg/src/golang"
	"text/template"
)

const Preamble = "Code generated by github.com/worldiety/macro. DO NOT EDIT."

type Engine struct {
	prog   *golang.Program
	prj    *ast.Prj
	prjMod *ast.Mod
}

func NewEngine(prog *golang.Program) *Engine {
	modPath := prog.Pkgs[0].Module.Path //this is not necessarily correct
	prjMod := ast.NewMod(modPath).SetLang(ast.LangGo)
	return &Engine{prog: prog, prj: ast.NewPrj("go-macro-prj").AddModules(prjMod), prjMod: prjMod}
}

func (e *Engine) Exec() error {
	for _, decl := range e.prog.TypeDecl {
		for _, macro := range decl.GetMacros() {
			goMacros := &GoMacros{
				parent: e,
				prog:   e.prog,
				typ:    decl,
			}
			tpl := template.New(decl.GetRef().String())
			tpl.Funcs(map[string]any{
				"go": func() *GoMacros {
					return goMacros
				},
			})
			tpl, err := tpl.Parse(macro.Template)
			if err != nil {
				return fmt.Errorf("macro parse error: %s: \n%v", err, macro.Origin)
			}

			var tmp bytes.Buffer
			if err := tpl.Execute(&tmp, nil); err != nil {
				return fmt.Errorf("macro execute error: %s: \n%v", err, macro.Origin)
			}

			fmt.Println("macro result:")
			fmt.Println(tmp.String())
		}
	}

	renderer := golang2.NewRenderer(golang2.Options{})
	artifact, err := renderer.Render(e.prj)
	if err != nil {
		return fmt.Errorf("failed to render go code: %w", err)
	}

	fmt.Println(artifact)
	return nil
}

type GoMacros struct {
	parent *Engine
	prog   *golang.Program
	typ    wdy.TypeDecl
}
